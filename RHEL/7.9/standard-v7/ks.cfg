# Configuration: RHEL version (7, 8, 9, 10) - used for conditional logic
{%- set rhel_version = 7 %}

%pre --interpreter /bin/bash --erroronfail --log=/root/ks.log

# Configuration: RHEL version (7, 8, 9, 10)
RHEL_VERSION={{ rhel_version }}

# Configuration: Minimum disk size for installation (in GB)
MINIMUM_DISK_SIZE_GB=100

# Debug: Log all available disks for troubleshooting
echo "=== Available Disks ===" > /tmp/disk.log
lsblk -dpno NAME,MODEL,SIZE >> /tmp/disk.log
echo "======================" >> /tmp/disk.log

# Identify the Dell BOSS disk based on the name (case-insensitive, partial match)
DISK=$(lsblk -dpno NAME,MODEL | grep -i "boss" | awk '{print $1}' | head -n 1)

# Log BOSS detection results
if [ -n "$DISK" ]; then
    echo "Dell BOSS disk found: $DISK" >> /tmp/disk.log
    echo "BOSS disk details:" >> /tmp/disk.log
    lsblk -dpno NAME,MODEL,SIZE | grep -i "boss" >> /tmp/disk.log
else
    echo "Dell BOSS disk not found (searched for 'boss' case-insensitive)" >> /tmp/disk.log
fi

# If Dell BOSS is not found, select the smallest available disk (minimum configurable size)
if [ -z "$DISK" ]; then
  echo "Dell BOSS disk not found. Selecting the smallest available disk (minimum ${MINIMUM_DISK_SIZE_GB}GB)."
  
  # Calculate minimum size in bytes
  MINIMUM_SIZE_BYTES=$((MINIMUM_DISK_SIZE_GB * 1024 * 1024 * 1024))
  
  DISK=$(lsblk -dpno NAME,SIZE,TYPE | grep -w 'disk' | grep -v zram | awk -v min_bytes="$MINIMUM_SIZE_BYTES" '
    {
      # Convert size to bytes for comparison
      size = $2
      unit = substr(size, length(size))
      value = substr(size, 1, length(size)-1)
      
      # Convert to bytes based on unit
      if (unit == "K") bytes = value * 1024
      else if (unit == "M") bytes = value * 1024 * 1024
      else if (unit == "G") bytes = value * 1024 * 1024 * 1024
      else if (unit == "T") bytes = value * 1024 * 1024 * 1024 * 1024
      else bytes = value  # assume bytes if no unit
      
      # Only include disks >= minimum size
      if (bytes >= min_bytes) {
        print $0
      }
    }
  ' | sort -k2 -h | head -n 1 | awk '{print $1}')
fi

# Check if a disk was found
if [ -z "$DISK" ]; then
  echo "Error: No suitable disks found (minimum ${MINIMUM_DISK_SIZE_GB}GB required)!" >/tmp/disk.log
  exit 1
fi

echo "=== FINAL SELECTION ===" >> /tmp/disk.log
echo "Using disk: $DISK" >> /tmp/disk.log
echo "Disk details:" >> /tmp/disk.log
lsblk -dpno NAME,MODEL,SIZE | grep "^$DISK " >> /tmp/disk.log
echo "======================" >> /tmp/disk.log

# Export the detected disk name to be used in the Kickstart configuration
echo "ignoredisk --only-use=$DISK" >> /tmp/pre-ks.cfg
echo "bootloader --append=\" crashkernel=auto\" --location=mbr --boot-drive=$DISK" >> /tmp/pre-ks.cfg
echo "clearpart --all --initlabel --drives=$DISK" >> /tmp/pre-ks.cfg
%end

%include /tmp/pre-ks.cfg

# Automatic partitioning
autopart --type=lvm

# use %pre-install for scripts after disk and network are configured, but before other stuff.

# Use text mode install
text
# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'
# System language
lang en_US.UTF-8

# Network information. Supports both IPv4 and IPv6 configuration.
# Note Multiple ip addresses can not be assigned to a single device using the network command. secondary ips need to be added in %post
# If two network lines use the same device, the second network will overwrite the first.

{%- set interface_physical = [] %}
{%- set interface_bond = [] %}
{%- set interface_vlan = [] %}

{%- for interface in network.interfaces %}
  {%- if interface.interfaceType == 'physical' %}
    {%- set interface_physical = (interface_physical.push(interface), interface_physical) %}
  {%- elif interface.interfaceType == 'bond' %}
    {%- set interface_bond = (interface_bond.push(interface), interface_bond) %}
  {%- elif interface.interfaceType == 'vlan' %}
    {%- set interface_vlan = (interface_vlan.push(interface), interface_vlan) %}
  {%- endif %}
{%- endfor %}

{# Use DNS servers from site configuration - separate IPv4 and IPv6 #}
{%- set ipv4_dns_list = [] %}
{%- set ipv6_dns_list = [] %}
{%- if siteConfig.DNSServers %}
  {%- for dns in siteConfig.DNSServers %}
    {%- if ':' in dns %}
      {%- set _ = ipv6_dns_list.push(dns) %}
    {%- else %}
      {%- set _ = ipv4_dns_list.push(dns) %}
    {%- endif %}
  {%- endfor %}
{%- endif %}
{%- set ipv4_dns_str = ipv4_dns_list | join(',') if ipv4_dns_list | length > 0 else '' %}
{%- set ipv6_dns_str = ipv6_dns_list | join(',') if ipv6_dns_list | length > 0 else '' %}

{# Set the hostname on a separate network command line #}
{% if serverInstance.label %}network --hostname={{ serverInstance.label}}{% endif %}

{# Macro to construct interface names #}    
{%- macro construct_interface_name(interface) -%}
  {%- if interface.interfaceType == 'physical' -%}
    phy{{ interface.typeInterfaceId }}
  {%- elif interface.interfaceType == 'bond' -%}
    bond{{ interface.typeInterfaceId }}
  {%- elif interface.interfaceType == 'vlan' -%}
    vlan{{ interface.vlanId }}
  {%- else -%}
    {{ interface.typeInterfaceId }}
  {%- endif %}
{%- endmacro -%}

{# Configure physical interfaces #}
{%- if interface_physical | length %}
  {%- for interface in interface_physical %}
    {%- set has_ipv4 = interface.ipv4Addresses | length > 0 %}
    {%- set has_ipv6 = interface.ipv6Addresses | length > 0 %}
    {%- if (has_ipv4 or has_ipv6) and (interface_vlan | length == 0) %}
      {%- if has_ipv4 %}
        {%- set ipv4_address = interface.ipv4Addresses[0] %}
      {%- endif %}
      {%- if has_ipv6 %}
        {%- set ipv6_address = interface.ipv6Addresses[0] %}
      {%- endif %}
      network --onboot=yes --device={{ interface.macAddress | lower }}{% if has_ipv4 %} --bootproto=static{% endif %}{% if has_ipv4 %}{% if ipv4_address.ip %} --ip={{ ipv4_address.ip }}{% endif %}{% if ipv4_address.netmask %} --netmask={{ ipv4_address.netmask }}{% endif %}{% if interface.routes and interface.routes[0].via %} --gateway={{ interface.routes[0].via }}{% endif %}{% else %} --noipv4{% endif %}{% if has_ipv6 %} --ipv6={{ ipv6_address.cidr }}{% if ipv6_address.gateway %} --ipv6gateway={{ ipv6_address.gateway }}{% endif %}{% else %} --noipv6{% endif %}{% if interface.mtu %} --mtu={{ interface.mtu }}{% endif %}{% if (has_ipv4 and ipv4_dns_str) or (has_ipv6 and ipv6_dns_str) %} --nameserver={% if has_ipv4 and ipv4_dns_str %}{{ ipv4_dns_str }}{% endif %}{% if has_ipv4 and has_ipv6 and ipv4_dns_str and ipv6_dns_str %},{% endif %}{% if has_ipv6 and ipv6_dns_str %}{{ ipv6_dns_str }}{% endif %}{% endif %} --activate
    {%- else %}
      network --device={{ interface.macAddress | lower }} --onboot=yes{% if interface.mtu %} --mtu={{ interface.mtu }}{% endif %} --noipv4 --noipv6
    {%- endif %}  
  {%- endfor %}
{%- endif %}

{# Configure bond interfaces #}
{%- if interface_bond | length %}
  {%- for interface in interface_bond %}
    {% set bond_name = construct_interface_name(interface) %}
    {% set bond_members = [] -%}

    {%- for member in interface.members %}
      {%- set member_interface_found = False %}
      {%- for iface in interface_physical %}
        {%- if member_interface_found == False and iface.typeInterfaceId == member.id %}
          {%- set member_interface_found = True %}
          {% set member_mac = iface.macAddress | lower %}
          {% set device_name = construct_interface_name(iface) %}
         
          {%- set bond_members = (bond_members.push(device_name), bond_members) %}
        {%- endif %}
      {%- endfor %}
    {%- endfor %}

    {% set bondslaves = bond_members | join(',') %}
    {%- set has_ipv4 = interface.ipv4Addresses | length > 0 %}
    {%- set has_ipv6 = interface.ipv6Addresses | length > 0 %}
    {%- if (has_ipv4 or has_ipv6) and (interface_vlan | length == 0) %}
      {%- if has_ipv4 %}
        {%- set ipv4_address = interface.ipv4Addresses[0] %}
      {%- endif %}
      {%- if has_ipv6 %}
        {%- set ipv6_address = interface.ipv6Addresses[0] %}
      {%- endif %}
      {% set bond_mode = interface.parameters.mode | default('802.3ad') %}
      network --device={{ bond_name }} --onboot=yes --bondslaves={{ bondslaves }}{% if has_ipv4 %} --bootproto=static{% endif %}{% if has_ipv4 %}{% if ipv4_address.ip %} --ip={{ ipv4_address.ip }}{% endif %}{% if ipv4_address.netmask %} --netmask={{ ipv4_address.netmask }}{% endif %}{% if interface.routes and interface.routes[0].via %} --gateway={{ interface.routes[0].via }}{% endif %}{% else %} --noipv4{% endif %}{% if has_ipv6 %} --ipv6={{ ipv6_address.cidr }}{% if ipv6_address.gateway %} --ipv6gateway={{ ipv6_address.gateway }}{% endif %}{% else %} --noipv6{% endif %} --bondopts=mode={{ bond_mode }}{% if interface.parameters.mii_monitor_interval %},miimon={{ interface.parameters.mii_monitor_interval }}{% endif %}{% if interface.parameters.lacp_rate %},lacp_rate={{ interface.parameters.lacp_rate }}{% endif %}{% if interface.parameters.transmit_hash_policy %},xmit_hash_policy={{ interface.parameters.transmit_hash_policy }}{% endif %}{% if (has_ipv4 and ipv4_dns_str) or (has_ipv6 and ipv6_dns_str) %} --nameserver={% if has_ipv4 and ipv4_dns_str %}{{ ipv4_dns_str }}{% endif %}{% if has_ipv4 and has_ipv6 and ipv4_dns_str and ipv6_dns_str %},{% endif %}{% if has_ipv6 and ipv6_dns_str %}{{ ipv6_dns_str }}{% endif %}{% endif %}{% if interface.mtu %} --mtu={{ interface.mtu }}{% endif %}
    {%- else %}
      {% set bond_mode = interface.parameters.mode | default('802.3ad') %}
      network --device={{ bond_name }} --onboot=yes --bondslaves={{ bondslaves }} --noipv4 --noipv6 --bondopts=mode={{ bond_mode }}{% if interface.parameters.mii_monitor_interval %},miimon={{ interface.parameters.mii_monitor_interval }}{% endif %}{% if interface.parameters.lacp_rate %},lacp_rate={{ interface.parameters.lacp_rate }}{% endif %}{% if interface.parameters.transmit_hash_policy %},xmit_hash_policy={{ interface.parameters.transmit_hash_policy }}{% endif %}{% if interface.mtu %} --mtu={{ interface.mtu }}{% endif %}
    {%- endif %}
  {%- endfor %}
{%- endif %}


{# Configure VLAN interfaces #}
{%- if interface_vlan | length %}
  {%- for interface in interface_vlan %}
    {%- set parent_interface_found = False %}
    {%- set has_ipv4 = interface.ipv4Addresses | length > 0 %}
    {%- set has_ipv6 = interface.ipv6Addresses | length > 0 %}
    {%- for iface in network.interfaces %}
      {%- if parent_interface_found == False and iface.interfaceType == interface.links[0].interfaceType and iface.typeInterfaceId == interface.links[0].id %}
        {% set parent_name = construct_interface_name(iface) %}
        {%- set parent_interface_found = True %}
        {%- set parent_mtu = iface.mtu %}
        {%- if has_ipv4 %}
          {%- set ipv4_address = interface.ipv4Addresses[0] %}
        {%- endif %}
        {%- if has_ipv6 %}
          {%- set ipv6_address = interface.ipv6Addresses[0] %}
        {%- endif %}
        network --vlanid={{ interface.vlanId }} --interfacename=vlan{{ interface.vlanId }} --device={{ parent_name }} --onboot=yes{% if has_ipv4 %} --bootproto=static{% endif %}{% if has_ipv4 %}{% if ipv4_address.ip %} --ip={{ ipv4_address.ip }}{% endif %}{% if ipv4_address.netmask %} --netmask={{ ipv4_address.netmask }}{% endif %}{% if interface.routes and interface.routes[0].via %} --gateway={{ interface.routes[0].via }}{% endif %}{% else %} --noipv4{% endif %}{% if has_ipv6 %} --ipv6={{ ipv6_address.cidr }}{% if ipv6_address.gateway %} --ipv6gateway={{ ipv6_address.gateway }}{% endif %}{% else %} --noipv6{% endif %}{% if (has_ipv4 and ipv4_dns_str) or (has_ipv6 and ipv6_dns_str) %} --nameserver={% if has_ipv4 and ipv4_dns_str %}{{ ipv4_dns_str }}{% endif %}{% if has_ipv4 and has_ipv6 and ipv4_dns_str and ipv6_dns_str %},{% endif %}{% if has_ipv6 and ipv6_dns_str %}{{ ipv6_dns_str }}{% endif %}{% endif %}{% if parent_mtu %} --mtu={{ parent_mtu }}{% endif %}
      {%- endif %}
    {%- endfor %}
  {%- endfor %}
{%- endif %}

%post --interpreter /bin/bash --erroronfail --log=/root/ks.log 

# Generate udev rules for interface renaming (conditional based on RHEL version and interface types)
# For RHEL 8: only rename if bonds or VLANs are present
# For RHEL 7, 9, 10: always rename
{%- if rhel_version == 8 and interface_bond | length == 0 and interface_vlan | length == 0 %}
SHOULD_RENAME_INTERFACES=false
{%- else %}
SHOULD_RENAME_INTERFACES=true
{%- endif %}

if [ "$SHOULD_RENAME_INTERFACES" = "true" ]; then
    cat <<EOL > /etc/udev/rules.d/70-persistent-net.rules
{%- for interface in interface_physical %}
SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="{{ interface.macAddress | lower }}", NAME="{{ construct_interface_name(interface) }}"
{%- endfor %}
EOL
fi

# Change old name to new interface name in networkmanager device names (only if renaming)
if [ "$SHOULD_RENAME_INTERFACES" = "true" ]; then
{%- for interface in interface_physical %}
    OLD_INTERFACE_NAME=$(nmcli device show | grep -B 2 -i {{ interface.macAddress }} | grep DEVICE | awk '{print $2}')
    sed -i "s/$OLD_INTERFACE_NAME/{{ construct_interface_name(interface) }}/g" /etc/NetworkManager/system-connections/${OLD_INTERFACE_NAME}.nmconnection
{%- endfor %}
fi

# Configure NetworkManager to assign IPs even when no carrier is detected
{%- for interface in interface_physical %}
{%- set has_ipv4 = interface.ipv4Addresses | length > 0 %}
{%- set has_ipv6 = interface.ipv6Addresses | length > 0 %}
{%- if has_ipv4 or has_ipv6 %}
INTERFACE_NAME="{{ construct_interface_name(interface) }}"
CONNECTION_FILE="/etc/NetworkManager/system-connections/${INTERFACE_NAME}.nmconnection"

# Add settings to handle interfaces without carrier
if [ -f "$CONNECTION_FILE" ]; then
    # Set connection.wait-device-timeout to 0 (don't wait for device)
    if ! grep -q "wait-device-timeout" "$CONNECTION_FILE"; then
        sed -i '/^\[connection\]/a wait-device-timeout=0' "$CONNECTION_FILE"
    fi
    
    # Set ipv4.may-fail=no to ensure IPv4 configuration doesn't fail
    {%- if has_ipv4 %}
    if ! grep -q "may-fail" "$CONNECTION_FILE"; then
        sed -i '/^\[ipv4\]/a may-fail=no' "$CONNECTION_FILE"
    fi
    {%- endif %}
    
    # Set ipv6.may-fail=no for IPv6 if configured (needed for IPv6-only environments)
    {%- if has_ipv6 %}
    if ! grep -q "\[ipv6\]" "$CONNECTION_FILE"; then
        echo "" >> "$CONNECTION_FILE"
        echo "[ipv6]" >> "$CONNECTION_FILE"
    fi
    if ! grep -q "may-fail" "$CONNECTION_FILE" | grep -A5 "\[ipv6\]"; then
        sed -i '/^\[ipv6\]/a may-fail=no' "$CONNECTION_FILE"
    fi
    {%- endif %}
fi
{%- endif %}
{%- endfor %}

# Need to add this to make the network start up properly after Reboot after interface renaming
{%- for interface in interface_bond %}

# Get the bond name from the argument
BOND_NAME="{{ construct_interface_name(interface) }}"

# Directory where the NetworkManager connection files are stored
CONFIG_DIR="/etc/NetworkManager/system-connections/"

# The file to modify based on bond_name
FILE="${CONFIG_DIR}/${BOND_NAME}.nmconnection"

# Line to insert
LINE_TO_INSERT="autoconnect-slaves=1"

# Insert the line after the [connection] section
awk -v LINE="$LINE_TO_INSERT" '/\[connection\]/ { print; print LINE; next }1' "$FILE" > "${FILE}.tmp" && mv "${FILE}.tmp" "$FILE"

chmod 600 "$FILE"

# Configure NetworkManager to assign IPs even when no carrier is detected for bond
{%- set has_ipv4 = interface.ipv4Addresses | length > 0 %}
{%- set has_ipv6 = interface.ipv6Addresses | length > 0 %}
{%- if has_ipv4 or has_ipv6 %}
# Add settings to handle bond interfaces without carrier
if [ -f "$FILE" ]; then
    # Set connection.wait-device-timeout to 0 (don't wait for device)
    if ! grep -q "wait-device-timeout" "$FILE"; then
        sed -i '/^\[connection\]/a wait-device-timeout=0' "$FILE"
    fi
    
    # Set ipv4.may-fail=no to ensure IPv4 configuration doesn't fail
    {%- if has_ipv4 %}
    if ! grep -q "may-fail" "$FILE"; then
        sed -i '/^\[ipv4\]/a may-fail=no' "$FILE"
    fi
    {%- endif %}
    
    # Set ipv6.may-fail=no for IPv6 if configured (needed for IPv6-only environments)
    {%- if has_ipv6 %}
    if ! grep -q "\[ipv6\]" "$FILE"; then
        echo "" >> "$FILE"
        echo "[ipv6]" >> "$FILE"
    fi
    if ! grep -q "may-fail" "$FILE" | grep -A5 "\[ipv6\]"; then
        sed -i '/^\[ipv6\]/a may-fail=no' "$FILE"
    fi
    {%- endif %}
fi
{%- endif %}

{%- endfor %}

# Add ssh keys to initial user(usually root)
{% set initial_username = serverInstance.osCredentials.initialUser %}
{% if initial_username %}
  {% set homedir = "/home/" + initial_username %}
{% else %}
    {% set initial_username = "root" %}
    {% set homedir = "/root" %}
{% endif %}

# Create the .ssh directory for the user if it doesn't exist
mkdir -p {{ homedir }}/.ssh
chmod 700 {{ homedir }}/.ssh
chown {{ initial_username }}:{{ initial_username }} {{ homedir }}/.ssh

# Add the management SSH key
{% if managementSSHKey %}echo "{{ managementSSHKey }}" >> {{ homedir }}/.ssh/authorized_keys{% endif %}

# Add additional user SSH keys from the array
{% for key in userSSHKeys %}
{% if key %}echo "{{ key }}" >> {{ homedir }}/.ssh/authorized_keys{% endif %}
{%- endfor %}

# Set correct permissions only if authorized_keys file exists
if [ -f "{{ homedir }}/.ssh/authorized_keys" ]; then
    chmod 600 {{ homedir }}/.ssh/authorized_keys
    chown {{ initial_username }}:{{ initial_username }} {{ homedir }}/.ssh/authorized_keys
fi

%end

# user password
{%- if initial_username and initial_username != "root" and serverInstance.osCredentials.initialPasswordEncrypted %}
  user --name={{ initial_username }} --password={{ serverInstance.osCredentials.initialPasswordEncrypted }} --plaintext
{%- endif %}

# root password
{% if serverInstance.osCredentials.initialPasswordEncrypted %}rootpw --plaintext {{serverInstance.osCredentials.initialPasswordEncrypted}}{% else %}rootpw --lock{% endif %}
# SELinux configuration
selinux --disabled
# Run the Setup Agent on first boot
firstboot --enable
# Do not configure the X Window System
skipx
# System services
services --enabled="chronyd"
# System timezone (conditional based on RHEL version)
{%- set ntp_servers_str = siteConfig.NTPServers | join(',') if siteConfig.NTPServers else 'pool.ntp.org' %}
{%- if rhel_version <= 8 %}
timezone UTC --isUtc --ntpservers={{ ntp_servers_str }}
{%- else %}
timezone UTC --utc
{%- for ntp_server in siteConfig.NTPServers if siteConfig.NTPServers else ['pool.ntp.org'] %}
timesource --ntp-server {{ ntp_server }}
{%- endfor %}
{%- endif %}

# Shutdown the system after installation
shutdown

%packages
@^minimal-environment
@standard
kexec-tools

%end

%addon com_redhat_kdump --enable --reserve-mb='auto'

%end